 \begin{notes}

{\large \textbf{Important}}

\begin{itemize}

\item For now, threading in `sequencing' works only under Clozure CL 1.12.1

\item Also, the synchronisation is not yet implemented.

\item The `sequencing'  is currently developed with the net as AREA.
 
\end{itemize}

Work in progress ...

\end{notes}

\bigskip

The sequencing is managed with the class of the same name described in the following table \ref{table:seq}. Each sequencing as an object is instantiated generating its own sequence with its own rule(s). Each parameter and function is accessible from the name or the `dub' (i.e. nickname) of this object leading to interact at any time with code or other sequencing instantiation.

\smallskip

The principle consists to estimate an occurrence according to the context defined by what I called a `dynamic buffer' -- as ordered events\footnote{The order is in time-inverse understanding that each computed event is pushed into the buffer as the first item of this buffer.} -- which is updated each time the computation is done by the function(s) set in routine. The `dynamic buffer' can be leaded by other buffer(s) if needed. The computation consists mainly to apply the function \glspl{next-event-probability} -- taking as key argument the remanence state of the net as boolean (\texttt{:remanence} \textit{nil} by default)  and the odds function (\texttt{:compute} set with the function \texttt{rnd-weighted} by default) of the current sequencing --  according to the rule defined by the slot of the same name. 

\bigskip 

\begin{table}[ht]
\small
\centering
\begin{tabular}{r*1{c>{\ttfamily}l}cll}
  &   & \normal{\head{Slot}} & \normal{\head{\hspace{2mm} Input}}
  & \normal{\head{Note}} \\
    \midrule
  \multirow{20}{*}{SEQUENCING} 
  &   & name & {\footnotesize SEQUENCING} &  \\
  &  \faCog & dub & \textit{symbol}$|$\textit{string} & `nickname' \\
  &  \faCog & description & \itshape string &   \\
  &  \faCog & net & {\footnotesize MLT$|$AREA} &   \\
        &  \faCog & remanence & \itshape boolean & of \texttt{net}  \\
  &   & buffer-in & \itshape list & (\glspl{osc-listen} \texttt{<osc-in>}) \\
  &   & buffer-out & \itshape list & (\glspl{send-udp} â€¦\texttt{<osc-out>}) \\
    &  \faCog & buffer-size & \itshape integer &  maximum size \\
    &  \faCog & buffer-thres & \itshape integer &  minimum size \\
        &  \faCog & pattern & \itshape list &  list of events \\
                  &  \faCode & rule & \itshape function & $\rightarrow$  \glspl{set-rule}  \\
        &  \faCode & routine & \textit{function} & $\rightarrow$  \glspl{set-routine} \\
        &  \faCog & odds & \textit{function} &  \\
  &  \faCog & pulse & \itshape number &  {\footnotesize relative duration factor}  \\
    &  \faCog & meter & \itshape number & time domain modulo  \\
      &  \faCog & sync & \textit{boolean} &   \\
%        &   & outset & \itshape boolean &  \\
  %      &   & offset & \itshape number &  \\
 % &   & counter & \itshape integer &   \\
    &  \begin{minipage}{.025\textwidth}\includegraphics[width=\linewidth]{1123}\end{minipage} & osc-in &  \textit{list}$|$\textit{integer} &  {\footnotesize port(s)[integer]}  \\ 
  &  \begin{minipage}{.025\textwidth}\includegraphics[width=\linewidth]{1123}\end{minipage} & osc-out & \textit{list}$|$\textit{integer} &  {\footnotesize IP[string]+port(s)[integer]}  \\ 
    &  \faCog & tag & \textit{symbol}$|$\textit{string} &   \\
    &   & mem-cache & \itshape hash-table &   \\
\end{tabular}
\caption{\label{table:seq}The sequencing class.}
\end{table}

\smallskip

The rule predefines the event as a partial clique or event. The rule(s) is(are) embedded in a \glspl{lambda*} function with as argument the sequencing object -- conventionally named \textit{self}.

\smallskip
 
Regarding the function(s) involve(s) in \glspl{set-routine}, the idea is to update the `dynamic buffer' as a complete clique or event. In case of more than one function, the processes are sequential. 

\smallskip

Concerning the routine, when it set, one thread as deamon is created in order to do the computation, which consists to fill the buffer-out according to the buffer-size. This `deamon' thread is located in the mem-cache with the key \textsl{compute}. When the routine is acting, a second thread is created to manage the buffer(s) involved in time by sending data via OSC -- see \texttt{+routine+} function. This `main' thread is located in the mem-cache with the key \textsl{routine}.

\bigskip
\bigskip

%\newpage
\noindent {\large \textbf{About synchronisation}}

\bigskip

First, some definitions in context:
\begin{description}
\item[\texttt{meter}] -- pattern of beats as the numerator of the time signature.
\item[\texttt{+beat+}] -- tempo as the ratio of the previous beats defined by the \texttt{meter}, i.e. the duration in second of one beat as a global variable allowing to control globally the speed of the play.
\item[\texttt{pulse}] -- minimal duration as the Least Common Multiple of the intended or expected rhythm.
\item[\texttt{*latency*}] -- time step of the \texttt{+clock+} as $dt$ in second.
\end{description}
   
%   \smallskip
%   
%Note when the synchronisation is effective as a boolean or as a number, the pulsation is set according to the value of this number as the factor of the meter, or the nearest factor according to the value of pulse by default. Then, the real value of the pulse is the value of \texttt{(cdr (sync <sequencing>))}.  
%
%Hence the synchronisation is done on the modulo of the pulsation with respect to the meter.
%\begin{lstlisting}[language=N3]
%(mod 
%   (/ +clock+ 
%      (* (cdr (sync <sequencing>)) 
%         (/ +beat+ *latency*))) 
%   (meter <sequencing>))   
%\end{lstlisting}
%
%The synchronisation of one sequencing is subordinated to another one. Then the setting of the synchronisation requires the referring sequencing followed by an integer as the index of the beat of this sequencing and more broadly as the modulo meter of this sequencing of this number (0 by default, i.e. first beat).

\bigskip
\bigskip

%\newpage
\noindent {\large \textbf{About time lag}}

\bigskip

When the computing time does not supply the buffer-out, a subroutine (according to the buffer-thres) takes over the routine until the complete filling of the buffer-out (according to the buffer-size and  taking into account the meter when the synchronisation is effective), or after the subroutine is completed. This subroutine can be silent (which is the default behavior), the sustained last event, or the call of a pattern or any kind of alternative routine.

\bigskip
\bigskip

\noindent {\large \textbf{Dynamic Markov Chain}}

\bigskip

See  4.7, 6.5.4 and 8.4 in \textsl{Journal of Generative Sonic Art} \citep{yi}. In short, what I call a `Dynamic Markov Chain' allows increasing or coercion decreasing the order in a manner that the transition probabilities do not reach 100\% for a single event.
 
See also code instance on the Annex \ref{ann:mcone} on page \pageref{ann:mcone}.

%\bigskip
%\bigskip
%
%\noindent {\large \textbf{Dynamic Cyclic Chain}}
%
%\bigskip

